using System.IdentityModel.Tokens.Jwt;
using System.Security.Claims;
using System.Security.Cryptography;
using System.Text;
using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.AspNetCore.Http.HttpResults;
using Microsoft.AspNetCore.Mvc;
using Microsoft.IdentityModel.Tokens;

var builder = WebApplication.CreateBuilder(args);

builder.Configuration.AddInMemoryCollection(new Dictionary<string, string?>
{
    ["Jwt:Issuer"] = "https://118118Money.com",
    ["Jwt:Audience"] = "spa-client",
    ["Jwt:SigningKey"] = "lw6v4Z3Ykm6uJ81r8yUKST0ZpudXtj2n"
});


builder.Services.AddAuthentication(options =>
    {
        options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
        options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;
    })
    .AddJwtBearer(options =>
    {
        options.TokenValidationParameters = new TokenValidationParameters
        {
            ValidateIssuer = true,
            ValidateAudience = true,
            ValidateLifetime = true,
            ValidateIssuerSigningKey = true,
            ValidIssuer = builder.Configuration["Jwt:Issuer"],
            ValidAudience = builder.Configuration["Jwt:Audience"],
            IssuerSigningKey = new SymmetricSecurityKey(
                Encoding.UTF8.GetBytes(builder.Configuration["Jwt:SigningKey"]!)),
            ClockSkew = TimeSpan.FromMinutes(1)
        };
    });

builder.Services.AddAuthorization();
builder.Services.AddSingleton<IRefreshTokenStore, InMemoryRefreshTokenStore>();


builder.Services.AddCors(o =>
{
    o.AddDefaultPolicy(p => p
        .WithOrigins("https://118118Money.com") // SPA origin
        .AllowAnyHeader()
        .AllowAnyMethod()
        .AllowCredentials());
});

builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();

var app = builder.Build();

if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}

app.UseHttpsRedirection();
app.UseCors();
app.UseAuthentication();
app.UseAuthorization();

// --- Helpers (local functions) ---
string CreateJwt(Guid userId, IConfiguration cfg, IEnumerable<Claim>? extraClaims = null)
{
    var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(cfg["Jwt:SigningKey"]!));
    var creds = new SigningCredentials(key, SecurityAlgorithms.HmacSha256);

    var claims = new List<Claim>
    {
        new(JwtRegisteredClaimNames.Sub, userId.ToString()),
        new(ClaimTypes.NameIdentifier, userId.ToString()),
    };
    if (extraClaims is not null) claims.AddRange(extraClaims);

    var token = new JwtSecurityToken(
        issuer: cfg["Jwt:Issuer"],
        audience: cfg["Jwt:Audience"],
        claims: claims,
        notBefore: DateTime.UtcNow,
        expires: DateTime.UtcNow.AddMinutes(10), // short-lived access token
        signingCredentials: creds);

    return new JwtSecurityTokenHandler().WriteToken(token);
}

async Task<Guid?> AuthenticateAsync(string username, string password)
{
    // TODO: replace with your real user check (EF Core / Identity / etc)
    await Task.CompletedTask;
    return (username == "demo" && password == "Password123!") ? Guid.Parse("aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee") : null;
}

var auth = app.MapGroup("/auth");

// POST /auth/login
auth.MapPost("/login", async Task<Results<Ok<LoginResponse>, UnauthorizedHttpResult>> (
    [FromBody] LoginDto dto,
    IRefreshTokenStore store,
    IConfiguration cfg,
    HttpResponse http) =>
{
    var userId = await AuthenticateAsync(dto.Username, dto.Password);
    if (userId is null) return TypedResults.Unauthorized();

    var accessToken = CreateJwt(userId.Value, cfg);
    var (refreshToken, tokenId) = await store.IssueAsync(userId.Value);

    // HttpOnly refresh token cookie
    http.Cookies.Append("rt", refreshToken, new CookieOptions
    {
        HttpOnly = true,
        Secure = true,
        SameSite = SameSiteMode.Strict,
        Expires = DateTimeOffset.UtcNow.AddDays(14)
    });

    return TypedResults.Ok(new LoginResponse(accessToken));
});

// POST /auth/refresh
auth.MapPost("/refresh", async Task<Results<Ok<LoginResponse>, UnauthorizedHttpResult>> (
    HttpRequest request,
    HttpResponse response,
    IRefreshTokenStore store,
    IConfiguration cfg) =>
{
    if (!request.Cookies.TryGetValue("rt", out var refreshToken))
        return TypedResults.Unauthorized();

    var userId = await store.ValidateAndRotateAsync(refreshToken);
    if (userId is null) return TypedResults.Unauthorized();

    var newAccess = CreateJwt(userId.Value, cfg);
    var (newRefresh, _) = await store.IssueAsync(userId.Value);

    response.Cookies.Append("rt", newRefresh, new CookieOptions
    {
        HttpOnly = true,
        Secure = true,
        SameSite = SameSiteMode.Strict,
        Expires = DateTimeOffset.UtcNow.AddDays(14)
    });

    return TypedResults.Ok(new LoginResponse(newAccess));
});

// GET /auth/me (protected)
auth.MapGet("/me", (ClaimsPrincipal user) =>
{
    var id = user.FindFirstValue(ClaimTypes.NameIdentifier);
    return TypedResults.Ok(new { userId = id });
}).RequireAuthorization();

// Sample protected API
var todos = app.MapGroup("/api/todos").RequireAuthorization();
todos.MapGet("/", () => new[] { "one", "two" });


app.MapGet("/ping", () => "pong")
    .WithName("Ping")
    .WithOpenApi();

app.Run();

public record LoginDto(string Username, string Password);
public record LoginResponse(string AccessToken);

public interface IRefreshTokenStore
{
    Task<(string token, Guid tokenId)> IssueAsync(Guid userId);
    Task<Guid?> ValidateAndRotateAsync(string presentedToken); // returns userId if valid + rotates
    Task RevokeAsync(Guid tokenId);
}

// Simple demo memory store — replace with persistent EF Core table in production.
public class InMemoryRefreshTokenStore : IRefreshTokenStore
{
    private readonly Dictionary<Guid, RefreshRecord> _store = new();
    private readonly object _lock = new();

    public Task<(string token, Guid tokenId)> IssueAsync(Guid userId)
    {
        var tokenId = Guid.NewGuid();
        var token = GenerateOpaqueToken();
        var rec = new RefreshRecord
        {
            Id = tokenId,
            UserId = userId,
            TokenHash = Hash(token),
            ExpiresUtc = DateTime.UtcNow.AddDays(14),
            RevokedUtc = null
        };
        lock (_lock) _store[tokenId] = rec;
        return Task.FromResult((token, tokenId));
    }
    
    public Task<Guid?> ValidateAndRotateAsync(string presentedToken)
    {
        var now = DateTime.UtcNow;
        var hash = Hash(presentedToken);
        RefreshRecord? match;
        lock (_lock)
        {
            match = _store.Values.FirstOrDefault(r =>
                r.TokenHash == hash && r.RevokedUtc is null && r.ExpiresUtc > now);
            if (match is null) return Task.FromResult<Guid?>(null);

            // rotate: revoke old, issue new
            _store[match.Id] = match with { RevokedUtc = now };
            var newId = Guid.NewGuid();
            var newToken = GenerateOpaqueToken();
            _store[newId] = new RefreshRecord
            {
                Id = newId,
                UserId = match.UserId,
                TokenHash = Hash(newToken),
                ExpiresUtc = now.AddDays(14),
                RevokedUtc = null
            };

            // stash new token value on thread for cookie writer? not needed here:
            // we return just the userId and caller will IssueAsync to create final cookie
        }
        return Task.FromResult<Guid?>(match.UserId);
    }
    
    public Task RevokeAsync(Guid tokenId)
    {
        lock (_lock)
        {
            if (_store.TryGetValue(tokenId, out var rec))
                _store[tokenId] = rec with { RevokedUtc = DateTime.UtcNow };
        }
        return Task.CompletedTask;
    }

    static string GenerateOpaqueToken()
    {
        var bytes = RandomNumberGenerator.GetBytes(32);
        return Convert.ToBase64String(bytes);
    }

    static string Hash(string value)
    {
        using var sha = SHA256.Create();
        var hash = sha.ComputeHash(Encoding.UTF8.GetBytes(value));
        return Convert.ToHexString(hash);
    }

    private record RefreshRecord
    {
        public required Guid Id { get; init; }
        public required Guid UserId { get; init; }
        public required string TokenHash { get; init; }
        public required DateTime ExpiresUtc { get; init; }
        public DateTime? RevokedUtc { get; init; }
    }
}



"use client";

import {useState, useRef} from "react";

const API_BASE = process.env.NEXT_PUBLIC_API_BASE ?? "https://localhost:7013";

export default function Page() {

    const [username, setUsername] = useState("");
    const [password, setPassword] = useState("");
    const [status, setStatus] = useState<null | string>(null);

    // access token in-memory (resets on full reload; that's OK)
    const accessTokenRef = useRef<string | null>(null);

    async function handleLogin(e: React.FormEvent<HTMLFormElement>) {
        e.preventDefault();
        setStatus("Signing in…");

        try {
            const res = await fetch(`${API_BASE}/auth/login`, {
                method: "POST",
                credentials: "include", // <-- send/receive cookies (refresh token)
                headers: {"Content-Type": "application/json"},
                body: JSON.stringify({username, password}),
            });

            if (!res.ok) {
                setStatus("Invalid credentials.");
                return;
            }

            const data: { accessToken: string } = await res.json();
            accessTokenRef.current = data.accessToken;
            setStatus("Signed in!");
            setUsername("");
            setPassword("");

        } catch (err) {
            setStatus("Error signing in.");
        }
    }

    // Example of calling a protected API using the in-memory access token
    async function callProtected() {
        setStatus("Calling /auth/me…");
        const token = accessTokenRef.current;
        if (!token) {
            setStatus("Please sign in first.");
            return;
        }

        const res = await fetch(`${API_BASE}/auth/me`, {
            method: "GET",
            credentials: "include", // keeps refresh flow possible server-side if you add one
            headers: {Authorization: `Bearer ${token}`},
        });

        if (res.status === 401) {
            // (Optional) You could attempt a silent refresh here by calling /auth/refresh,
            // then retry with the new access token.
            setStatus("Unauthorized (token expired?).");
            return;
        }

        const json = await res.json();
        setStatus(`Hello user ${json.userId}`);
    }

    return (
        <div
            className="font-sans grid grid-rows-[20px_1fr_20px] items-center justify-items-center min-h-screen p-8 pb-20 gap-16 sm:p-20">
            <main className="flex flex-col gap-[32px] row-start-2 items-center sm:items-start">
                <div className="w-full max-w-sm">
                    <h1 className="text-2xl font-semibold mb-6">Welcome to auth</h1>

                    <form onSubmit={handleLogin} className="space-y-4">
                        <div>
                            <label className="block text-sm mb-1" htmlFor="username">
                                Username
                            </label>
                            <input
                                id="username"
                                value={username}
                                onChange={(e) => setUsername(e.target.value)}
                                className="w-full rounded-xl border px-3 py-2 outline-none focus:ring"
                                autoComplete="username"
                                required
                            />
                        </div>

                        <div>
                            <label className="block text-sm mb-1" htmlFor="password">
                                Password
                            </label>
                            <input
                                id="password"
                                type="password"
                                value={password}
                                onChange={(e) => setPassword(e.target.value)}
                                className="w-full rounded-xl border px-3 py-2 outline-none focus:ring"
                                autoComplete="current-password"
                                required
                            />
                        </div>

                        <button
                            type="submit"
                            className="w-full rounded-xl bg-black text-white py-2 hover:opacity-90">
                            Sign in
                        </button>
                    </form>

                    <div className="mt-4 flex items-center gap-2">
                        <button
                            onClick={callProtected}
                            className="rounded-xl border px-3 py-2 hover:bg-gray-50"
                        >
                            Call /auth/me
                        </button>
                        <span className="text-sm text-gray-600">{status}</span>
                    </div>

                    <p className="mt-4 text-xs text-gray-500">
                        Note: the API should set an <code>HttpOnly</code> refresh-token cookie on{" "}
                        <code>/auth/login</code>. This page stores the access token only in memory and
                        sends it via <code>Authorization: Bearer</code> for protected requests.
                    </p>
                </div>
            </main>
        </div>
    )
}




==== 
"use client";

import React, { Fragment, useEffect, useState, useMemo } from "react";
import Seo from "@/shared/layouts-components/seo/seo";
import {
    Document,
    Page,
    PDFViewer,
    PDFDownloadLink,
    StyleSheet,
    Text,
    Font,
    Image,
    View
} from '@react-pdf/renderer';



Font.register({
    family: 'Oswald',
    src: 'https://fonts.gstatic.com/s/oswald/v13/Y_TKV6o8WovbUd3m_X9aAA.ttf'
});

// Interface for the server response structure
interface PDFConfig {
    data: Record<string, string>;
    styles: any;
    content: {
        header: string;
        title: string;
        author: string;
        image: string;
        subtitle: string;
        labels: {
            name: string;
            balance: string;
            summary: string;
        };
    };
}

const Demo = () => {
    const [isClient, setIsClient] = useState(false);
    const [config, setConfig] = useState<PDFConfig | null>(null);

    useEffect(() => {
        setIsClient(true);

        // Mimicking configuration being served as JSON content from a server
        const fetchConfig = async () => {
            // Simulated delay for server response
            await new Promise(resolve => setTimeout(resolve, 800));

            const jsonResponse = {
                data: {
                    "data.name": "John Doe",
                    "data.email": "john.doe@example.com",
                    "data.balance": "£563.80",
                    "data.summary": "You have spent considerably more than you should have this month",
                },
                styles: {
                    body: {
                        paddingTop: 35,
                        paddingBottom: 65,
                        paddingHorizontal: 35,
                    },
                    title: {
                        fontSize: 24,
                        textAlign: 'center',
                        fontFamily: 'Oswald'
                    },
                    author: {
                        fontSize: 12,
                        textAlign: 'center',
                        marginBottom: 40,
                    },
                    subtitle: {
                        fontSize: 18,
                        margin: 12,
                        fontFamily: 'Oswald'
                    },
                    text: {
                        margin: 12,
                        fontSize: 14,
                        textAlign: 'justify',
                        fontFamily: 'Times-Roman'
                    },
                    image: {
                        marginVertical: 15,
                        marginHorizontal: 100,
                    },
                    header: {
                        fontSize: 12,
                        marginBottom: 20,
                        textAlign: 'center',
                        color: 'grey',
                    },
                    pageNumber: {
                        position: 'absolute',
                        fontSize: 12,
                        bottom: 30,
                        left: 0,
                        right: 0,
                        textAlign: 'center',
                        color: 'grey',
                    },
                    tabularData: {
                        flexDirection: 'row',
                    },
                    tabularLabel: {
                        fontWeight: 'bold',
                        width: '33.33%',
                        paddingTop: 10,
                        paddingBottom: 10,
                        marginRight: 10,
                    },
                    tabularValue: {
                        paddingTop: 10,
                        paddingBottom: 10,
                        textAlign: 'justify',
                        flex: 1
                    }
                },
                content: {
                   
                }
            };

            setConfig(jsonResponse as any);
        };

        fetchConfig();
    }, []);

    const styles = useMemo(() => {
        if (!config) return null;
        return StyleSheet.create(config.styles);
    }, [config]);

    const doc = config && styles ? (
        <Document>
            <Page
                style={styles.body}
            >
                <Text style={styles.header} fixed>
                    ~ Created with react-pdf ~
                </Text>
                <Text style={styles.title}>Don Quijote de la Mancha</Text>
                <Text style={styles.author}>Miguel de Cervantes</Text>
                <Image
                    style={styles.image}
                    src="/images/quijote1.jpg"
                />
                <Text style={styles.subtitle}>
                    Capítulo I: Que trata de la condición y ejercicio del famoso hidalgo D. Quijote de la Manchas
                </Text>
                <View style={styles.tabularData}>
                    <Text style={styles.tabularLabel}>Name</Text>
                    <Text style={styles.tabularValue}>{config.data["data.name"]}</Text>
                </View>
                <View style={styles.tabularData}>
                    <Text style={styles.tabularLabel}>Balance</Text>
                    <Text style={styles.tabularValue}>{config.data["data.balance"]}</Text>
                </View>
                <View style={styles.tabularData}>
                    <Text style={styles.tabularLabel}>Summary</Text>
                    <Text style={styles.tabularValue}>{config.data["data.summary"]}</Text>
                </View>
                <Text
                    style={styles.pageNumber}
                    render={({ pageNumber, totalPages }) => (
                        `${pageNumber} / ${totalPages}`
                    )}
                    fixed
                />
            </Page>
        </Document>
    ) : null;

    return (
        <Fragment>
            <Seo title={"Demo"} />
            {/* <!-- Start:: row-2 --> */}
            <div className="grid grid-cols-12 gap-6">
                <div className="xl:col-span-4 col-span-12">
                    <div className="box overflow-hidden">
                        <div className="box-header justify-content-between">
                            Code
                        </div>
                        <div className="box-body">
                            TODO
                        </div>
                    </div>
                </div>
                <div className="xl:col-span-8 col-span-12">
                    <div>
                        {isClient && config && doc ? (
                            <>
                                <PDFViewer className="w-full h-svh">{doc}</PDFViewer>
                                <div className="mt-4 flex justify-end">
                                    <PDFDownloadLink
                                        document={doc}
                                        fileName="demo.pdf"
                                        className="ti-btn ti-btn-primary-full !inline-flex"
                                    >
                                        {({ loading }) => (loading ? 'Loading document...' : 'Download PDF')}
                                    </PDFDownloadLink>
                                </div>
                            </>
                        ) : (
                            <div className="flex flex-col items-center justify-center h-svh bg-white/50 backdrop-blur-sm rounded-lg border-2 border-dashed border-gray-200">
                                <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-primary mb-4"></div>
                                <p className="text-gray-500 font-medium">Fetching configuration and preparing PDF...</p>
                            </div>
                        )}
                    </div>
                </div>
            </div>
            {/* <!-- End:: row-3 --> */}
        </Fragment>
    );
};

export default Demo;

 public async Task<byte[]> MergeAsync(byte[] localBytes, Stream uploadedStream)
    {
        // Copy an uploaded stream into a seekable memory stream
        using var uploadedMs = new MemoryStream();
        await uploadedStream.CopyToAsync(uploadedMs);
        uploadedMs.Position = 0;

        using var localMs = new MemoryStream(localBytes, writable: false);
        using var merged = new PdfSharpCore.Pdf.PdfDocument();

        // Place the uploaded document FIRST
        using (var uploadedDoc = PdfReader.Open(uploadedMs, PdfDocumentOpenMode.Import))
        {
            foreach (var pdfPage in uploadedDoc.Pages)
            {
                merged.AddPage(pdfPage);
            }
        }

        // Then append the local document
        using (var localDoc = PdfReader.Open(localMs, PdfDocumentOpenMode.Import))
        {
            foreach (var pdfPage in localDoc.Pages)
            {
                merged.AddPage(pdfPage);
            }
        }

        using var outMs = new MemoryStream();
        merged.Save(outMs, closeStream: false);
        return outMs.ToArray();
    }

app.MapPost("/uploads", async (IFormFile file) =>
{
    if (file.Length == 0)
    {
        return Results.BadRequest("No file uploaded or file is empty.");
    }
    
    if (!file.ContentType.Equals("application/pdf", StringComparison.OrdinalIgnoreCase))
    {
        Console.WriteLine($"Warning: unexpected content type {file.ContentType}");
    }
    
    if(string.IsNullOrWhiteSpace(file.FileName))
        return Results.BadRequest("No file name");
    
    // Load the local PDF and merge with the uploaded one (uploaded should come first)
    var localBytes = await File.ReadAllBytesAsync(
        @"C:\code\TestLocalAuth\TestLocalAuth\TestLocalAuth\docs\Main-Document.pdf");

    await using var uploadedStream = file.OpenReadStream();

    var merger = new DocumentMerger();
    var mergedBytes = await merger.MergeAsync(localBytes, uploadedStream);

    var downloadName = Path.GetFileNameWithoutExtension(file.FileName);
    if (string.IsNullOrWhiteSpace(downloadName)) downloadName = "uploaded";
    var resultName = $"merged-{downloadName}.pdf";

    return Results.File(mergedBytes, "application/pdf", resultName);
}).DisableAntiforgery();
